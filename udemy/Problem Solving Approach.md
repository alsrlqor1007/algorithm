## Problem Solving Approach

### Algorithm

A process or set of steps to accomplish a certain task.
대부분의 프로그래밍 개발은 알고리즘과 연관이 있다고 할 수 있다. 어떤 문제를 해결하고자 하는 개발자에게는 기본이고, 또 면접에서 매우 중요하다.

- 알고리즘 실력을 향상시키려면?
  문제해결 방법 또는 계획을 세울 줄 알아야 하고, 대표적인 문제 해결 패턴들을 익혀야 한다.
  <br/>
- 문제 해결 단계

```
1. 문제 이해하기
2. 구체적인 예시 보기
3. 파악하기
4. 해결하기/단순화하기
5. 코드 보완 및 리팩토링하기
```

<br><br/>

### Step 1: Understand The Problem

문제를 마주했을 때, 아래 5가지를 고려할 수 있어야 한다. 아래 단계를 통해 문제를 명확하게 숙지해야 한다. 혼자 풀거나 일을 하더라도 문제를 이해하는 것은 매우 중요하다.

```
1. 문제를 나의 언어로 재정의할 수 있는가?
2. 문제의 입력 값이 무엇인가? 어떻게 구성되어 있는가?
3. 솔루션으로 인해 도출되는 결과 값은 무엇인가?
4. 문제를 해결하기 위해 충분한 정보를 갖고 있는가? 그 정보만으로 입력 값에 대한 예상 결과 값을 도출할 수 있는가?
5. 문제 속 중요한 자료들은 어떻게 관리해야 하는가? 문제에서 중요한 요소는 무엇이고, 어떻게 이름을 붙일 것인가?
```

예시: 두 숫자의 합을 도출하는 함수를 작성하라.
(Write a function which takes two numbers and returns their sum.)

```
1. 재정의: 덧셈(Implement addition)
2. 입력 값: 정수? 실수? string 형태?
3. 결과 값: 정수? 실수? string 형태?
4. 이 예시에서는 PASS
5. 변수: 함수명 add, 입력 값 num1, num2, 결과 값 sum
```

<br><br/>

### Step 2: Concrete Examples

구체적인 예시를 통해 문제를 더욱 명확히 이해할 수 있고, 도출한 최종 솔루션을 검증할 수 있는 수단이 된다. 입력 값을 알고 있으니 그에 따른 올바른 결과가 도출되는지 확인할 수 있는 것이다.
단순히 문제를 더 잘 이해하고 해결하는 것보다도 실무에서 이를 활용한 이점들이 있다. 만약에 인스타그램과 같은 서비스에서 새로운 기능을 개발한다면 이미 주어져 있는 입력 값이라고 할 수 있는 `User Stories` 고려부터 시작한다. User Action을 알고 있으니 그에 따라 다음 어떤 결과가 나와야 하는지 고민하는 것이다.
`Unit test`도 예시를 활용하는 사례이다. 정해진 입력 값에 어떤 결과가 나와야 하는지 테스트하면서 개발한다.

아래의 순서로 예시를 활용한다.

```
1. 간단한 예시부터 세운다.
2. 조금 더 복잡한 예시를 세운다.
3. 빈 입력 값으로 앞에서 세운 예시를 확인한다. 로직이 어떻게 돌아가는지 인사이트를 얻을 수 있다.
4. 잘못된 입력 값으로 앞에서 세운 예시를 확인한다.
```

예시: 문자열을 받으면 각 문자의 갯수를 반환하는 함수를 작성하라.
(Write a function which takes in a string and returns counts of each character in the string.)

1. 간단한 예시

```JSX
charCount("aaaa"); // {a: 4}
charCount("hello"); // {h: 1, e: 1, l: 2, o: 1}
```

2. 더 복잡한 예시

```JSX
"my phone number is 182763"
"Hello hi"
// 이러한 더 복잡한 예시들은 문제를 본격적으로 풀기 전에 문제를 더 잘 이해하는데 도움이 된다.
```

3. 빈 입력 값

```JSX
charCount("");
// 빈 값을 넣으면 빈 문자열이 나와야 하는가? 아니면 null, falsy, undefined 또는 에러가 나와야 하는가?
```

4. 잘못된 입력 값

```JSX
charCount(5); // 문자열이 아닌 다른 타입의 데이터가 들어갈 경우(edge case 고려하기)
```

<br><br/>

### Step 3: Break It Down

실제 문제 해결 순서대로 따라가며 풀어보는 것이다. 엄격하게 모든 수도코드를 작성하거나 유효 문법을 사용해야 하는 것은 아니다. 면접에서 어떤 순서로 문제를 접근할지 소개할 때 도움이 되기도 한다. 그리고 실제 코드로 구현하지는 못했어도 문제를 어떻게 접근했는지 어필할 수 있다.
다시 말해 로직이 어떤 순서로 어떤 단계를 거칠지 스스로 명확하게 하는 것이다. 본격적인 코드를 작성하기 전에 떠올린 로직에 대해 다시 되돌아보게 하며, 오래 고민되는 부분이나 잘 못 이해한 부분을 발견할 수 있다.

예시: 문자열을 받으면 각 문자의 갯수를 반환하는 함수를 작성하라.
(Write a function which takes in a string and returns counts of each character in the string.)

```JSX
function charCount(str) {
  // do something
  // return an object with  keys that are lowerCase alphanumeric charters in the string;
}
```

```JSX
function charCount(str) {
  // 마지막에 반환할 객체 생성
  // 각 문자열 순환
    // 만약에 해당 문자가 문자형이거나 숫자형이고 객체의 키로 존재한다면 키값 갯수를 하나 더한다.
    // 만약에 문자형이거나 숫자형이지만 객체의 키로 존재하지 않는 문자라면 새로 키를 추가하고 값을 1로 지정한다.
    // 만약 문자형이나 숫자형이 아닌 다른 자료형이라면 그 어떤 처리도 하지 않는다.
  // 객체 반환
}
```

결국 문제를 어떻게 해결할지 단계와 흐름을 사람의 언어로 수도 코드(pseudo code)를 작성하는 얘기였다.

<br><br/>

### Step 4: Solve Or Simplify

앞 단계까지 수도코드를 작성했다고 해서 끝난 것이 아니다. 풀이가 명확하고 확실해진다면 실제 코드를 작성해 문제를 풀면 되지만, 그렇지 않다면 문제를 단순화해서 접근해야 한다. 그냥 쉬운 문제로 바꿔서 풀자는 것이 아니라 주어진 문제 상황 속에서 막힌 부분을 배제하고 그 나머지에 집중하는 것이다. 면접이라면 단순히 풀지 못하고 포기하는 것이 아니라 이렇게 조금이라도 접근한 부분을 보여주는 것이 좋다. 또는, 문제를 단순화 시킴으로써 어려워하던 부분에서 해결 인사이트를 다시 찾게 될 수 있다. 따라서 막혔지만 어디서부터 시작해야 할지 알고 있다면 포기하지 말고 단순화해서 다시 생각해 보는 것을 추천한다.

```
1. 풀이 과정 중 해결되지 않는 핵심 부분을 찾아낸다.
2. 잠시 해당 부분을 배제하고 문제를 다시 바라본다.
3. 단순해진 솔루션을 작성한다.
4. 다시 해결되지 않았던 부분으로 돌아가 고민한다.
```

단순 반복문 구현에 어려움을 느낄 일은 없지만 앞에 보던 예시에서 문자열을 순환하는데 어려움을 느꼈다고 가정해보자. 반복문 적용하는 부분을 제외하고 문자열의 첫 번째 인덱스부터 직접 고려해보며 조건문을 적용하는 부분만 우선 구현하는 것이다. 그 다음 두 번째, 세 번째 인덱스를 보며 반복문 적용을 제외한 풀이만을 진행한다. 또는 객체 생성에 어려움을 느낀다면 객체 생성을 제외하고 반복문 구현부터 시작하는 것이다. 이처럼 풀이 과정 속에서 해결법을 모르는 부분이 있다면 그 부분만을 제외하고 나머지 부분만 풀어보는 것이다.
아래 예시는 문자열을 순환할 때 `해당 문자의 타입이나 대/소문자를 판별하는 방법을 모른다고 가정`하고 이를 제외한 풀이 예시이다.

```JSX
function charCount(str) {
  // 마지막에 반환할 객체 생성
  let result = {};
  // 각 문자열 순환
  for (let i = 0; i < str.length; i++) {
    let char = str[i];
    // 만약에 해당 문자가 문자형이거나 숫자형이고 객체의 키로 존재한다면 키값 갯수를 하나 더한다.
    if (result[char] > 0) {
      result[char]++;
    }
    // 만약에 문자형이거나 숫자형이지만 객체의 키로 존재하지 않는 문자라면 새로 키를 추가하고 값을 1로 지정한다.
    else {
      result[char] = 1;
    };
  }
    // 만약 문자형이나 숫자형이 아닌 공백이나 기호 등 다른 자료형이라면 그 어떤 처리도 하지 않는다.
  // 객체 반환
  return result;
}
```

이렇게라도 풀이를 하면 이제 해결하지 못한 부분으로 돌아가 그 부분만 다시 고민한다.
위 예시에서는 대/소문자 구분하는 방법을 모른다고 가정하고 제외하고 풀었기 때문에 나중에 힌트를 얻었거나 검색을 통해 방법을 찾았다면 다시 돌아가 수정한다.

```JSX
let char = str[i].toLowerCase();
```

이제 여기까지 왔다면 마지막으로 alphanumeric(글자와 숫자를 쓴) 결과 값을 도출하는 것만 해결하면 된다.

<br><br/>

### Step 5: Look Back and Refactor

가장 중요한 단계라고 한다. 모든 조건을 만족하는 풀이를 냈다고 해서 끝나는 것이 아니다. 혼자 일하거나 당장 업무 납기가 내일까지라면 모르겠지만 작성한 코드를 계속해서 다듬는 과정은 매우 중요하다. 로직 내 개별 컴포넌트별로 또는 한 줄씩 다시 보면서 코드가 어떻게 읽히는지, 겉으로 어떻게 보이는지, 가독성이 높은지, 쉽게 읽히는지 등을 회고한다.

- Refactoring Questions

```
- 올바른 결과가 나오는가?
- 다른 접근 방식으로 결과를 도출할 수 있는가?
- 로직이 한 눈에 이해가 되는가?
- 결과 값이나 로직을 다른 문제 상황에도 적용할 수 있는가?
- 로직의 performance를 향상시킬 수 있는가?
- 다른 리팩토링 방식이 있는가?
- 다른 사람들은 어떻게 풀었는가?
```

꼭 위와 같은 단계로 꼭 새롭게 리팩토링을 해야 하는 것은 아니지만, 제목에 나와있듯 다시 본인의 코드를 돌아보고 분석하는 과정은 뛰어난 개발자로 성장하는데 있어 꼭 필요하다.

아래는 앞의 예시를 리팩토링을 통해 한 번 수정한 코드이다. 정규표현식을 사용해서 간단하게 만들었다.

```JSX
function charCount(str) {
  let obj = {};
  for (let i = 0; i < str.length; i++) {
    let char = str[i].toLowerCase();
    if (/[a-z0-9]/.test(char)) {
      if (obj[char] > 0) {
        obj[char]++;
      } else {
        obj[char] = 1;
      };
    }
  }
  return obj;
}
```

여기서 또 수정할 수 있는게 있다면 무엇일까. 길게 쓴 반복문을 `for...of 문`으로 대체할 수 있다.

```JSX
function charCount(str) {
  let obj = {};
  for (let char of str) {
    char = str[i].toLowerCase();
    if (/[a-z0-9]/.test(char)) {
      if (obj[char] > 0) {
        obj[char]++;
      } else {
        obj[char] = 1;
      };
    }
  }
  return obj;
}
```

다음은 사소한 문법 수정이다. 반복문 내에 선언한 조건문들은 실제로 굉장히 단순한 역할을 하지만 몇 줄 이상씩 차지하고 있다. `obj[char]`의 값이 0이라면 falsy 값이라는 점을 이용했다.

```JSX
function charCount(str) {
  let obj = {};
  for (let char of str) {
    char = str[i].toLowerCase();
    if (/[a-z0-9]/.test(char)) {
      // obj[char]가 truthy 값이라면 하나씩 더하고 아니라면 1로 지정한다.
      obj[char] = ++obj[char] || 1;
    }
  }
  return obj;
}
```

그리고 가장 먼저 리팩토링에 사용한 정규 표현식이 편하긴 하지만, 정규 표현식 사용법에 대해 잘 모르거나 크롬 브라우저에서 발생한 이슈를 고려하면 다른 방식으로도 해당 코드를 대체할 수 있다. `.charCodeAt()` 메서드를 활용해 단순 숫자 비교 형태로 별도 함수를 만들었다. 정규 표현식을 활용한 방법보다 훨씬 빠르다고 알려져 있다.

```JSX
function charCount(str) {
  let obj = {};
  for (let char of str) {
    if (isAlphaNumeric(char)) {
      char = char.toLowerCase();
      obj[char] = ++obj[char] || 1;
    }
  }
  return obj;
}

// charCodeAt() 메서드를 활용해 반복문에서 각 문자가 조건을 만족하는지 확인하는 별도 함수 생성
function isAlphaNumeric(char) {
  let code = charCodeAt(0);
  if (!(code > 47 && code < 58) && // numeric (0-9)
      !(code > 64 && code < 91) && // upper alpha (A-Z)
      !(code > 96 && code < 123)) { // lower alpha (a-z)
        return false;
      }
  return true;
}
```

이렇게 작성하면 `charCount()` 함수에 가독성을 더욱 높이기도 하며, 정규 표현식을 사용했을 때보다 복잡도 측면에서도 훨씬 효율이 좋다.
