## Analyzing Performance of Arrays and Objects

### Objects

정해진 순서 없이 빠르게 데이터의 접근이나 탐색, 삽입과 삭제 작업을 처리하고자 할 때 객체 형태를 활용한다.

- 객체 데이터를 작업할 때 시간 복잡도

```JSX
삽입: O(1)
삭제: O(1)
탐색: O(n)
접근: O(1)
```

- Built-In Object Methods

```JSX
Object.keys: O(n)
Object.values: O(n)
Object.entries: O(n)
```

`Object.keys`는 객체의 키를 모두 반환하는 함수로, 조회 후 반환 배열에 삽입하는 과정을 해당 객체가 갖고 있는 키의 갯수(n번) 만큼 수행한다.

```JSX
hasOwnProperty: O(1)
```

`hasOwnProperty`는 인자로 들어가는 값을 객체의 키로 갖고 있는지 확인하는 함수로 boolean 값을 반환한다. 키의 값을 탐색하는 것이 아니라 단순히 키에 접근하는 작업이라서 객체에 1번만 접근한다.

배열 형태의 자료는 순서가 존재하기 때문에 어떤 작업을 하냐에 따라 속도가 느릴 수 있지만 객체 형태의 자료는 순서를 고려하지 않기 때문에 비교적 빠르다.
<br></br>

### Arrays

객체와 다르게 순서가 존재한다. (There is an intrinsic ordering.)
순서를 고려해야 하는 데이터를 다룰 때 사용한다. 탐색과 접근을 할 때는 객체와 마찬가지로 각각 `O(n)`, `O(1)`의 시간 복잡도를 갖고 있어 항상 빠르게 가능하다. 삽입이나 삭제 작업을 할 때는 위치에 따라 시간 복잡도가 증가하기도 한다.

만약 배열의 가장 마지막 위치에 새로운 요소를 삽입하거나 마지막에 위치한 요소를 삭제하는 경우의 시간 복잡도는 항상 일정하게 `O(1)`이다. 배열에는 각 요소마다 대응되는 인덱스 값이 있다. 이를 활용해 마지막에 요소를 추가하거나 마지막 요소로 바로 접근해서 삭제해주면 되기 때문이다. 객체와 비슷하게 일정하고 간단하다.

하지만 시간 복잡도가 증가하는 경우는 배열의 서두에 삽입이나 삭제 작업을 할 때이다. 각 요소마다 대응되는 인데스 값이 있다고 했다. 서두에 데이터를 하나 삽입하면 해당 요소의 인덱스 값은 0이 되고 그 뒤 모든 요소의 인덱스 값에 1씩 변동이 생긴다. 따라서 기존 배열 요소의 갯수 만큼 인덱스 값 증가 작업의 횟수가 결정되며 `O(n)`의 복잡도를 가진다. 삭제도 동일하다.

따라서 빈 배열이 아니라면 push( )와 pop( ) 함수가 항상 shift( )와 unshift( )보다 빠르다고 할 수 있다.

- Built-In Array Methods

```JSX
push: O(1)
pop: O(1)
shift: O(n)
unshift: O(n)
concat: O(n)
slice: O(n)
splice: O(n)
sort: O(n * log n)
forEach/map/filter/reduce/etc: O(n)
```

`concat`은 배열을 합치는 함수로 합치는 배열의 갯수(n) 만큼의 시간 복잡도를 가진다. ` slice`는 배열의 일부 또는 전체를 복사해서 반환하기 때문에 시간 복잡도가 반환하는 배열의 크기에 비례한다. `splice`는 특정 요소를 삭제하고 새로운 요소를 삽입하는 함수이며 활용할 수 있는 경우가 다양하다. 서두나 마지막 위치에 요소를 삽입하거나 특정 요소를 대체할 수 있다. 특정 요소를 대체하는 경우 해당 위치를 기준으로 그 뒤의 모든 요소의 인덱스에 변동이 있기 때문에 O(n)이다.

정렬에 대한 시간 복잡도는 나중에 다른 섹션에서 다룰 예정이라고 한다.
